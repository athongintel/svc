#ifndef  __TOM_AES-GCM__
#define __TOM_AES-GCM__

	#include "crypto-utils.h"
	
	#define ERROR_KEYLENGTH_NOT_SUPPORTED "Key length is not supported"
	#define ERROR_DATALENGTH_NOT_SUPPORTED "Data length is not supported"
	
	#define BLOCK_BYTESIZE 16
	#define BLOCK_BITSIZE BLOCK_BYTESIZE<<3
		
	enum SecurityParameter : int {
		SECU_128 = 128,
		SECU_120 = 120,
		SECU_112 = 112,
		SECU_104 = 104,
		SECU_96 = 96
	};
	
	class AESGCMStatic{
		friend class AESGCM;
		uint8_t* blockR;
		uint8_t* hashSubKey;
		
		public:		
			AESGCMStatic(){
				blockR = (uint8_t*)malloc(BLOCK_BYTESIZE);
				blockR[BLOCK_BYTESIZE-1] = 0xE1;
				hashSubKey = (uint8_t*)malloc(BLOCK_BYTESIZE);
				//The hash subkey for the GHASH function is generated by applying the block cipher to the â€œzero" block.
			}
	}
	
	
	class AESGCM{
		
		uint8_t* key;
		int keyLength;
		enum SecurityParameter secuParam;
		AESGCMStatic staticVariables;
		
		private:
			
			//--	shift the whole array to the right by 1 bit
			static void bitRightShiftBlock(uint8_t* block);
			//--	return Z = X^Y
			static void xorBlock(uint8_t* blockZ, const uint8_t* blockX, const uint8_t* blockY);
			//--	return Z = X*Y
			static bool mulBlock(uint8_t* blockZ, const uint8_t* blockX, const uint8_t* blockY);
			static bool gHash(uint8_t* block, size_t blockLen);
		
		public:			
			//--	SECURITY PARAMETERS
			AESGCM(int keyLength);
			~AESGCM();
			void setKey(const uint8_t* key, enum SecurityParameter secuParam);
			bool encrypt(const uint8_t* data, const size_t* dataLen, uint8_t* encrypted, size_t* encryptedLen);
			bool decrypt(const uint8_t* encrypted, const size_t* encryptedLen, uint8_t* data, size_t* dataLen);
	};

#endif
